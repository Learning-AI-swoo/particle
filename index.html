<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VUIM 2026 3D Cylinder Particle System</title>
<style>
body {
margin: 0;
overflow: hidden;
background: #0a0a0f;
font-family: 'Courier New', monospace;
}
canvas {
display: block;
cursor: pointer;
}
#overlay {
position: absolute;
top: 20px;
left: 20px;
color: #00ff88;
font-size: 11px;
pointer-events: none;
text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
line-height: 1.6;
}
#instructions {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
color: #00ff88;
font-size: 12px;
text-align: center;
opacity: 0.7;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="overlay"></div>
<div id="instructions">HOVER: Expand & Tilt | CLICK: Explode | Mouse to Rotate</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Particle system
class Particle {
constructor(x, y, z, text, index, total) {
this.baseX = x;
this.baseY = y;
this.baseZ = z;
this.x = x;
this.y = y;
this.z = z;
this.text = text;
this.index = index;
this.total = total;
this.vx = 0;
this.vy = 0;
this.vz = 0;
this.exploded = false;
this.returnSpeed = 0.05;
this.waveOffset = (index / total) * Math.PI * 2;
}

update(time, explosionActive, mouseInfluence) {
if (explosionActive && !this.exploded) {
this.vx = (Math.random() - 0.5) * 15;
this.vy = (Math.random() - 0.5) * 15;
this.vz = (Math.random() - 0.5) * 15;
this.exploded = true;
}

if (this.exploded) {
this.x += this.vx;
this.y += this.vy;
this.z += this.vz;
this.vx *= 0.98;
this.vy *= 0.98;
this.vz *= 0.98;

if (!explosionActive) {
const dx = this.baseX - this.x;
const dy = this.baseY - this.y;
const dz = this.baseZ - this.z;
this.x += dx * this.returnSpeed;
this.y += dy * this.returnSpeed;
this.z += dz * this.returnSpeed;

if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5 && Math.abs(dz) < 0.5) {
this.exploded = false;
this.x = this.baseX;
this.y = this.baseY;
this.z = this.baseZ;
}
}
}

// Wave motion
const wave = Math.sin(time * 0.002 + this.waveOffset) * 20;
this.y = this.exploded ? this.y : this.baseY + wave + mouseInfluence.tilt;
}

draw(rotX, rotY, scale, centerX, centerY) {
const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let x = this.x;
let y = this.y;
let z = this.z;

// Rotate Y
let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

// Rotate X
let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

// Scale & perspective
const perspective = 800;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;
const size = 2 + scaleZ * 2;

// Color based on depth
const brightness = Math.floor(155 + z * 0.2);
const alpha = scaleZ * 0.8;

ctx.fillStyle = `rgba(0, ${brightness}, 255, ${alpha})`;
ctx.beginPath();
ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
ctx.fill();

// Text overlay
if (this.index % 8 === 0 && scaleZ > 0.6) {
ctx.fillStyle = `rgba(0, 255, 136, ${alpha * 0.6})`;
ctx.font = `${10 * scaleZ}px Courier New`;
ctx.fillText(this.text, screenX + 5, screenY);
}

return { screenX, screenY, scaleZ, size };
}
}

// Satellite particle
class Satellite {
constructor(radius, speed, offset) {
this.radius = radius;
this.speed = speed;
this.angle = offset;
this.orbitY = (Math.random() - 0.5) * 200;
}

update() {
this.angle += this.speed;
}

draw(rotX, rotY, scale, centerX, centerY) {
let x = Math.cos(this.angle) * this.radius;
let y = this.orbitY;
let z = Math.sin(this.angle) * this.radius;

const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

const perspective = 800;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;

ctx.fillStyle = `rgba(255, 100, 0, ${scaleZ * 0.7})`;
ctx.beginPath();
ctx.arc(screenX, screenY, 3 * scaleZ, 0, Math.PI * 2);
ctx.fill();

return { screenX, screenY, scaleZ };
}
}

// Generate cylinder particles
const particles = [];
const text = "VUIM 2026";
const radius = 150;
const height = 300;
const rings = 30;
const particlesPerRing = 24;

for (let i = 0; i < rings; i++) {
const y = -height / 2 + (height / rings) * i;
for (let j = 0; j < particlesPerRing; j++) {
const angle = (j / particlesPerRing) * Math.PI * 2;
const x = Math.cos(angle) * radius;
const z = Math.sin(angle) * radius;
const char = text[particles.length % text.length];
particles.push(new Particle(x, y, z, char, particles.length, rings * particlesPerRing));
}
}

// Satellites
const satellites = [];
for (let i = 0; i < 5; i++) {
satellites.push(new Satellite(250 + i * 30, 0.01 + i * 0.005, (i / 5) * Math.PI * 2));
}

// Animation state
let rotX = 0.3;
let rotY = 0;
let targetRotX = 0.3;
let targetRotY = 0;
let scale = 1;
let targetScale = 1;
let explosionActive = false;
let explosionTimer = 0;
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;

// Mouse interaction
canvas.addEventListener('mousemove', (e) => {
mouseX = e.clientX;
mouseY = e.clientY;
targetRotY = (mouseX / canvas.width - 0.5) * Math.PI;
targetRotX = (mouseY / canvas.height - 0.5) * Math.PI * 0.5 + 0.3;
targetScale = 1.2;
});

canvas.addEventListener('mouseleave', () => {
targetScale = 1;
});

canvas.addEventListener('click', () => {
if (!explosionActive) {
explosionActive = true;
explosionTimer = Date.now();
}
});

// Animation loop
function animate() {
const time = Date.now();
ctx.fillStyle = 'rgba(10, 10, 15, 0.15)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Smooth rotation & scale
rotX += (targetRotX - rotX) * 0.05;
rotY += (targetRotY - rotY) * 0.05;
scale += (targetScale - scale) * 0.05;

// Auto-rotate
rotY += 0.005;

// Explosion timeout
if (explosionActive && time - explosionTimer > 3000) {
explosionActive = false;
}

// Mouse influence
const mouseInfluence = {
tilt: (mouseY / canvas.height - 0.5) * 30
};

// Update & draw particles
particles.forEach(p => p.update(time, explosionActive, mouseInfluence));

// Sort by depth
const rendered = particles.map(p => ({
particle: p,
screen: p.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2)
})).sort((a, b) => a.screen.scaleZ - b.screen.scaleZ);

// Draw connections
ctx.strokeStyle = 'rgba(0, 255, 136, 0.1)';
ctx.lineWidth = 1;
for (let i = 0; i < rendered.length; i++) {
for (let j = i + 1; j < Math.min(i + 3, rendered.length); j++) {
const a = rendered[i].screen;
const b = rendered[j].screen;
const dist = Math.hypot(a.screenX - b.screenX, a.screenY - b.screenY);
if (dist < 80) {
ctx.beginPath();
ctx.moveTo(a.screenX, a.screenY);
ctx.lineTo(b.screenX, b.screenY);
ctx.stroke();
}
}
}

// Draw satellites
satellites.forEach(s => {
s.update();
s.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2);
});

// Overlay data
overlay.innerHTML = `
SYSTEM: VUIM PARTICLE CORE<br>
PARTICLES: ${particles.length}<br>
ROTATION: X ${(rotX * 57.3).toFixed(1)}° Y ${(rotY * 57.3).toFixed(1)}°<br>
SCALE: ${scale.toFixed(2)}x<br>
STATUS: ${explosionActive ? 'EXPLODED' : 'STABLE'}<br>
SATELLITES: ${satellites.length} ACTIVE<br>
MOUSE: [${mouseX.toFixed(0)}, ${mouseY.toFixed(0)}]
`;

requestAnimationFrame(animate);
}

animate();

// Resize handler
window.addEventListener('resize', () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});
</script>
</body>
</html>
