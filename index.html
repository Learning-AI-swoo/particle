<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VUIM 2026 Cylindrical Text Particle System</title>
<style>
body {
margin: 0;
overflow: hidden;
background: #0a0a0f;
font-family: 'Courier New', monospace;
}
canvas {
display: block;
cursor: pointer;
}
#overlay {
position: absolute;
top: 20px;
left: 20px;
color: #00ff88;
font-size: 11px;
pointer-events: none;
text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
line-height: 1.6;
}
#instructions {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
color: #00ff88;
font-size: 12px;
text-align: center;
opacity: 0.7;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="overlay"></div>
<div id="instructions">HOVER: Expand & Tilt | CLICK: Explode | Mouse to Rotate</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Text to particle converter
function textToParticles(text, fontSize, spacing) {
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
tempCanvas.width = 600;
tempCanvas.height = 100;
tempCtx.font = 'bold ' + fontSize + 'px Arial';
tempCtx.fillStyle = 'white';
tempCtx.textAlign = 'center';
tempCtx.textBaseline = 'middle';
tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);

const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
const particles = [];

for (let y = 0; y < tempCanvas.height; y += spacing) {
for (let x = 0; x < tempCanvas.width; x += spacing) {
const index = (y * tempCanvas.width + x) * 4;
if (imageData.data[index + 3] > 128) {
particles.push({
x: x - tempCanvas.width / 2,
y: y - tempCanvas.height / 2
});
}
}
}

return particles;
}

// Map text particles to cylinder
function mapToCylinder(textParticles, radius, height, repeats) {
const cylinderParticles = [];
const textWidth = 600;

for (let repeat = 0; repeat < repeats; repeat++) {
textParticles.forEach(function(p, index) {
const normalizedX = (p.x + textWidth / 2) / textWidth;
const angle = normalizedX * Math.PI * 2 + (repeat * Math.PI * 2 / repeats);
const yPos = (p.y / 100) * height + (repeat * height / repeats) - height / 2;

const x = Math.cos(angle) * radius;
const z = Math.sin(angle) * radius;
const y = yPos;

cylinderParticles.push({
x: x,
y: y,
z: z,
angle: angle,
repeat: repeat,
originalIndex: index
});
});
}

return cylinderParticles;
}

// Particle class
class Particle {
constructor(x, y, z, index, total, angle) {
this.baseX = x;
this.baseY = y;
this.baseZ = z;
this.x = x;
this.y = y;
this.z = z;
this.index = index;
this.total = total;
this.angle = angle;
this.vx = 0;
this.vy = 0;
this.vz = 0;
this.exploded = false;
this.returnSpeed = 0.05;
this.waveOffset = (index / total) * Math.PI * 2;
this.hue = (angle / (Math.PI * 2)) * 360;
}

update(time, explosionActive, mouseInfluence) {
if (explosionActive && !this.exploded) {
this.vx = (Math.random() - 0.5) * 15;
this.vy = (Math.random() - 0.5) * 15;
this.vz = (Math.random() - 0.5) * 15;
this.exploded = true;
}

if (this.exploded) {
this.x += this.vx;
this.y += this.vy;
this.z += this.vz;
this.vx *= 0.98;
this.vy *= 0.98;
this.vz *= 0.98;

if (!explosionActive) {
const dx = this.baseX - this.x;
const dy = this.baseY - this.y;
const dz = this.baseZ - this.z;
this.x += dx * this.returnSpeed;
this.y += dy * this.returnSpeed;
this.z += dz * this.returnSpeed;

if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5 && Math.abs(dz) < 0.5) {
this.exploded = false;
this.x = this.baseX;
this.y = this.baseY;
this.z = this.baseZ;
}
}
}

// Wave motion
const wave = Math.sin(time * 0.002 + this.waveOffset) * 10;
if (!this.exploded) {
const waveAngle = this.angle + wave * 0.01;
const radius = Math.sqrt(this.baseX * this.baseX + this.baseZ * this.baseZ);
this.x = Math.cos(waveAngle) * radius;
this.z = Math.sin(waveAngle) * radius;
this.y = this.baseY + mouseInfluence.tilt * 0.5;
}
}

draw(rotX, rotY, scale, centerX, centerY) {
const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let x = this.x;
let y = this.y;
let z = this.z;

// Rotate Y
let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

// Rotate X
let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

// Perspective
const perspective = 800;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;
const size = 1.5 + scaleZ * 1.5;

// Pastel rainbow color
const alpha = scaleZ * 0.8;
const lightness = 75;
ctx.fillStyle = 'hsla(' + this.hue + ', 70%, ' + lightness + '%, ' + alpha + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
ctx.fill();

// Soft glow
ctx.fillStyle = 'hsla(' + this.hue + ', 90%, ' + (lightness + 10) + '%, ' + (alpha * 0.2) + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, size * 2.5, 0, Math.PI * 2);
ctx.fill();

return { screenX: screenX, screenY: screenY, scaleZ: scaleZ, size: size };
}
}

// Satellite particle
class Satellite {
constructor(radius, speed, offset) {
this.radius = radius;
this.speed = speed;
this.angle = offset;
this.orbitY = (Math.random() - 0.5) * 300;
}

update() {
this.angle += this.speed;
}

draw(rotX, rotY, scale, centerX, centerY) {
let x = Math.cos(this.angle) * this.radius;
let y = this.orbitY;
let z = Math.sin(this.angle) * this.radius;

const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

const perspective = 800;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;

ctx.fillStyle = 'rgba(255, 180, 100, ' + (scaleZ * 0.6) + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, 2.5 * scaleZ, 0, Math.PI * 2);
ctx.fill();

return { screenX: screenX, screenY: screenY, scaleZ: scaleZ };
}
}

// Generate cylindrical text particles
const textParticles = textToParticles("VUIM 2026", 60, 2);
const cylinderRadius = 180;
const cylinderHeight = 400;
const textRepeats = 8;
const cylinderPositions = mapToCylinder(textParticles, cylinderRadius, cylinderHeight, textRepeats);

const particles = cylinderPositions.map(function(pos, i) {
return new Particle(pos.x, pos.y, pos.z, i, cylinderPositions.length, pos.angle);
});

// Satellites
const satellites = [];
for (let i = 0; i < 5; i++) {
satellites.push(new Satellite(350 + i * 40, 0.008 + i * 0.004, (i / 5) * Math.PI * 2));
}

// Animation state
let rotX = 0.2;
let rotY = 0;
let targetRotX = 0.2;
let targetRotY = 0;
let scale = 1;
let targetScale = 1;
let explosionActive = false;
let explosionTimer = 0;
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;

// Mouse interaction
canvas.addEventListener('mousemove', function(e) {
mouseX = e.clientX;
mouseY = e.clientY;
targetRotY = (mouseX / canvas.width - 0.5) * Math.PI * 0.8;
targetRotX = (mouseY / canvas.height - 0.5) * Math.PI * 0.4 + 0.2;
targetScale = 1.25;
});

canvas.addEventListener('mouseleave', function() {
targetScale = 1;
});

canvas.addEventListener('click', function() {
if (!explosionActive) {
explosionActive = true;
explosionTimer = Date.now();
}
});

// Animation loop
function animate() {
const time = Date.now();
ctx.fillStyle = 'rgba(10, 10, 15, 0.25)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

// Smooth rotation & scale
rotX += (targetRotX - rotX) * 0.05;
rotY += (targetRotY - rotY) * 0.05;
scale += (targetScale - scale) * 0.05;

// Auto-rotate
rotY += 0.004;

// Explosion timeout
if (explosionActive && time - explosionTimer > 3000) {
explosionActive = false;
}

// Mouse influence
const mouseInfluence = {
tilt: (mouseY / canvas.height - 0.5) * 40
};

// Update particles
particles.forEach(function(p) {
p.update(time, explosionActive, mouseInfluence);
});

// Sort by depth
const rendered = particles.map(function(p) {
return {
particle: p,
screen: p.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2)
};
}).sort(function(a, b) {
return a.screen.scaleZ - b.screen.scaleZ;
});

// Draw connections
ctx.strokeStyle = 'rgba(0, 255, 136, 0.05)';
ctx.lineWidth = 0.5;
for (let i = 0; i < rendered.length; i += 8) {
for (let j = i + 1; j < Math.min(i + 4, rendered.length); j++) {
const a = rendered[i].screen;
const b = rendered[j].screen;
const dist = Math.hypot(a.screenX - b.screenX, a.screenY - b.screenY);
if (dist < 40) {
ctx.beginPath();
ctx.moveTo(a.screenX, a.screenY);
ctx.lineTo(b.screenX, b.screenY);
ctx.stroke();
}
}
}

// Draw satellites
satellites.forEach(function(s) {
s.update();
s.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2);
});

// Overlay data
overlay.innerHTML = 'SYSTEM: VUIM PARTICLE CORE<br>PARTICLES: ' + particles.length + '<br>ROTATION: X ' + (rotX * 57.3).toFixed(1) + '° Y ' + (rotY * 57.3).toFixed(1) + '°<br>SCALE: ' + scale.toFixed(2) + 'x<br>STATUS: ' + (explosionActive ? 'EXPLODED' : 'STABLE') + '<br>SATELLITES: ' + satellites.length + ' ACTIVE<br>MOUSE: [' + mouseX.toFixed(0) + ', ' + mouseY.toFixed(0) + ']';

requestAnimationFrame(animate);
}

animate();

// Resize handler
window.addEventListener('resize', function() {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});
</script>
</body>
</html>
