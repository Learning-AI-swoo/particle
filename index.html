<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VUIM 2026 Cylindrical Particle System</title>
<style>
body {
margin: 0;
overflow: hidden;
background: #0a0a0f;
font-family: 'Courier New', monospace;
}
canvas {
display: block;
cursor: pointer;
}
#overlay {
position: absolute;
top: 20px;
left: 20px;
color: #00ff88;
font-size: 11px;
pointer-events: none;
text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
line-height: 1.6;
}
#instructions {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
color: #00ff88;
font-size: 12px;
text-align: center;
opacity: 0.7;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="overlay"></div>
<div id="instructions">HOVER: Expand & Tilt | CLICK: Explode | Mouse to Rotate</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Text to particle converter with higher density
function textToParticles(text, fontSize, spacing) {
const tempCanvas = document.createElement('canvas');
const tempCtx = tempCanvas.getContext('2d');
tempCanvas.width = 1200;
tempCanvas.height = 150;
tempCtx.font = 'bold ' + fontSize + 'px Arial';
tempCtx.fillStyle = 'white';
tempCtx.textAlign = 'center';
tempCtx.textBaseline = 'middle';
tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);

const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
const particles = [];

for (let y = 0; y < tempCanvas.height; y += spacing) {
for (let x = 0; x < tempCanvas.width; x += spacing) {
const index = (y * tempCanvas.width + x) * 4;
if (imageData.data[index + 3] > 128) {
particles.push({
x: x,
y: y
});
}
}
}

return { particles: particles, width: tempCanvas.width, height: tempCanvas.height };
}

// Map text to cylinder surface
function mapTextToCylinder(textData, radius, repeats) {
const cylinderParticles = [];
const textWidth = textData.width;
const textHeight = textData.height;
const totalHeight = textHeight * repeats;

textData.particles.forEach(function(p) {
for (let r = 0; r < repeats; r++) {
const angle = (p.x / textWidth) * Math.PI * 2;
const yPos = (p.y + r * textHeight) - totalHeight / 2;
const normalizedAngle = angle / (Math.PI * 2);
const hue = normalizedAngle * 360;

cylinderParticles.push({
x: Math.cos(angle) * radius,
y: yPos,
z: Math.sin(angle) * radius,
angle: angle,
hue: hue,
layer: r
});
}
});

return cylinderParticles;
}

// Particle class
class Particle {
constructor(x, y, z, angle, hue, index, total) {
this.baseX = x;
this.baseY = y;
this.baseZ = z;
this.x = x;
this.y = y;
this.z = z;
this.angle = angle;
this.hue = hue;
this.index = index;
this.total = total;
this.vx = 0;
this.vy = 0;
this.vz = 0;
this.exploded = false;
this.returnSpeed = 0.05;
this.waveOffset = (index / total) * Math.PI * 2;
}

update(time, explosionActive, mouseInfluence) {
if (explosionActive && !this.exploded) {
this.vx = (Math.random() - 0.5) * 15;
this.vy = (Math.random() - 0.5) * 15;
this.vz = (Math.random() - 0.5) * 15;
this.exploded = true;
}

if (this.exploded) {
this.x += this.vx;
this.y += this.vy;
this.z += this.vz;
this.vx *= 0.98;
this.vy *= 0.98;
this.vz *= 0.98;

if (!explosionActive) {
const dx = this.baseX - this.x;
const dy = this.baseY - this.y;
const dz = this.baseZ - this.z;
this.x += dx * this.returnSpeed;
this.y += dy * this.returnSpeed;
this.z += dz * this.returnSpeed;

if (Math.abs(dx) < 0.5 && Math.abs(dy) < 0.5 && Math.abs(dz) < 0.5) {
this.exploded = false;
this.x = this.baseX;
this.y = this.baseY;
this.z = this.baseZ;
}
}
} else {
// Wave motion along cylinder
const wave = Math.sin(time * 0.002 + this.waveOffset) * 8;
const waveAngle = this.angle + wave * 0.008;
const radius = Math.sqrt(this.baseX * this.baseX + this.baseZ * this.baseZ);
this.x = Math.cos(waveAngle) * radius;
this.z = Math.sin(waveAngle) * radius;
this.y = this.baseY + mouseInfluence.tilt * 0.3;
}
}

draw(rotX, rotY, scale, centerX, centerY) {
const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let x = this.x;
let y = this.y;
let z = this.z;

// Rotate Y
let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

// Rotate X
let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

// Perspective
const perspective = 1000;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;
const size = 1.5 + scaleZ * 1.2;

// Vibrant rainbow color
const alpha = scaleZ * 0.85;
ctx.fillStyle = 'hsla(' + this.hue + ', 90%, 55%, ' + alpha + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
ctx.fill();

// Glow
ctx.fillStyle = 'hsla(' + this.hue + ', 95%, 65%, ' + (alpha * 0.3) + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, size * 2, 0, Math.PI * 2);
ctx.fill();

return { screenX: screenX, screenY: screenY, scaleZ: scaleZ };
}
}

// Satellite particle
class Satellite {
constructor(radius, speed, offset) {
this.radius = radius;
this.speed = speed;
this.angle = offset;
this.orbitY = (Math.random() - 0.5) * 350;
}

update() {
this.angle += this.speed;
}

draw(rotX, rotY, scale, centerX, centerY) {
let x = Math.cos(this.angle) * this.radius;
let y = this.orbitY;
let z = Math.sin(this.angle) * this.radius;

const cosX = Math.cos(rotX);
const sinX = Math.sin(rotX);
const cosY = Math.cos(rotY);
const sinY = Math.sin(rotY);

let tempX = x * cosY - z * sinY;
let tempZ = x * sinY + z * cosY;
x = tempX;
z = tempZ;

let tempY = y * cosX - z * sinX;
tempZ = y * sinX + z * cosX;
y = tempY;
z = tempZ;

const perspective = 1000;
const scaleZ = perspective / (perspective + z);
const screenX = centerX + x * scale * scaleZ;
const screenY = centerY + y * scale * scaleZ;

ctx.fillStyle = 'rgba(255, 150, 80, ' + (scaleZ * 0.7) + ')';
ctx.beginPath();
ctx.arc(screenX, screenY, 2.5 * scaleZ, 0, Math.PI * 2);
ctx.fill();

return { screenX: screenX, screenY: screenY, scaleZ: scaleZ };
}
}

// Generate particles
const textData = textToParticles("VUIM 2026", 100, 2);
const cylinderRadius = 200;
const repeats = 6;
const cylinderPositions = mapTextToCylinder(textData, cylinderRadius, repeats);

const particles = cylinderPositions.map(function(pos, i) {
return new Particle(pos.x, pos.y, pos.z, pos.angle, pos.hue, i, cylinderPositions.length);
});

// Satellites
const satellites = [];
for (let i = 0; i < 5; i++) {
satellites.push(new Satellite(380 + i * 45, 0.008 + i * 0.004, (i / 5) * Math.PI * 2));
}

// Animation state
let rotX = 0.2;
let rotY = 0;
let targetRotX = 0.2;
let targetRotY = 0;
let scale = 0.9;
let targetScale = 0.9;
let explosionActive = false;
let explosionTimer = 0;
let mouseX = canvas.width / 2;
let mouseY = canvas.height / 2;

// Mouse interaction
canvas.addEventListener('mousemove', function(e) {
mouseX = e.clientX;
mouseY = e.clientY;
targetRotY = (mouseX / canvas.width - 0.5) * Math.PI * 0.6;
targetRotX = (mouseY / canvas.height - 0.5) * Math.PI * 0.3 + 0.2;
targetScale = 1.1;
});

canvas.addEventListener('mouseleave', function() {
targetScale = 0.9;
});

canvas.addEventListener('click', function() {
if (!explosionActive) {
explosionActive = true;
explosionTimer = Date.now();
}
});

// Animation loop
function animate() {
const time = Date.now();
ctx.fillStyle = 'rgba(10, 10, 15, 0.25)';
ctx.fillRect(0, 0, canvas.width, canvas.height);

rotX += (targetRotX - rotX) * 0.05;
rotY += (targetRotY - rotY) * 0.05;
scale += (targetScale - scale) * 0.05;

// Auto-rotate
rotY += 0.003;

if (explosionActive && time - explosionTimer > 3000) {
explosionActive = false;
}

const mouseInfluence = {
tilt: (mouseY / canvas.height - 0.5) * 50
};

particles.forEach(function(p) {
p.update(time, explosionActive, mouseInfluence);
});

const rendered = particles.map(function(p) {
return {
particle: p,
screen: p.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2)
};
}).sort(function(a, b) {
return a.screen.scaleZ - b.screen.scaleZ;
});

// Connections
ctx.strokeStyle = 'rgba(0, 255, 136, 0.04)';
ctx.lineWidth = 0.5;
for (let i = 0; i < rendered.length; i += 10) {
for (let j = i + 1; j < Math.min(i + 3, rendered.length); j++) {
const a = rendered[i].screen;
const b = rendered[j].screen;
const dist = Math.hypot(a.screenX - b.screenX, a.screenY - b.screenY);
if (dist < 35) {
ctx.beginPath();
ctx.moveTo(a.screenX, a.screenY);
ctx.lineTo(b.screenX, b.screenY);
ctx.stroke();
}
}
}

satellites.forEach(function(s) {
s.update();
s.draw(rotX, rotY, scale, canvas.width / 2, canvas.height / 2);
});

overlay.innerHTML = 'SYSTEM: VUIM PARTICLE CORE<br>PARTICLES: ' + particles.length + '<br>ROTATION: X ' + (rotX * 57.3).toFixed(1) + '° Y ' + (rotY * 57.3).toFixed(1) + '°<br>SCALE: ' + scale.toFixed(2) + 'x<br>STATUS: ' + (explosionActive ? 'EXPLODED' : 'STABLE') + '<br>SATELLITES: ' + satellites.length + ' ACTIVE<br>MOUSE: [' + mouseX.toFixed(0) + ', ' + mouseY.toFixed(0) + ']';

requestAnimationFrame(animate);
}

animate();

window.addEventListener('resize', function() {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});
</script>
</body>
</html>
